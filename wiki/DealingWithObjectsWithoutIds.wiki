The ValueEncoder currently relies on DataObjectUtils to extract the ID from an object and to extract the object from an ID.  So, what should we do when the object is null or not yet persisted to the DB?

In my own apps, I've used a special IDs of "-1" and "new" to indicate null objects.  At that point, I auto-create a new object to work with.  I don't register the object with the context, however, because the object is in an inconsistent state.  If the user navigates away, and comes back, a new object would be created and any subsequent commits will fail.  So, what I've done instead is persisted the object and left registration up to the page code.

To address new objects: If the user leaves and comes back, the persisted object is shown rather than a new one being created, but the context never gets dirty.  We can probably take care of this behind the scenes in the ValueEncoder, providing we have access to the ApplicationStateManager.  The obvious follow-up question is whether this is the right thing to do all the time.  I don't know for certain, but not storing it in the session largely means it'll be lost on any sort of redirect, unless the user explicitly passes the object along through Java code.


Thinking out loud a bit:

  * The special IDs should be configurable so the user can get the URLs they'd like.
  * We may be able to use child contexts so that the object is at least registered without dirtying the primary context.  I've avoided this myself because associating objects in different contexts is not possible.

(Robert) I approached this problem in a slightly different fashion in tapestry 3, when I wrote the CayenneDataObjectSqueezeAdaptor.  What I did was to special-case each of the three cases: transient object, new object, and a committed object (one with an id).  For the transient object, I just serialized the object using the default tapestry/object serialization code.  For objects with id's, I did something like what we're doing now.  For new objects, I seralized the (temporary) objectid, and stored the object into a map.  Then on server-side "deserialization," I fetched the new object from the map.

In reality, the data squeezer delegated the new object responsibilities to separate interface; but in practice, I almost always wound up storing the new objects in a session-based map, keyed off the temporary object id.

In my current incarnation of T5/cayenne applications, I do something similar.
I have a service "NewObjRegistry" that is responsible for keeping tabs on newly created objects, and providing a temporary, unique key for them. My current implementation of this service uses an LRU map to avoid keeping references to "abandoned" new objects around.  The key stored is just the hash code of the object. Incidentally, looking over my code again, the NewObjRegistry is probably better termed "ObjRegistry" since it ends up handling transient objects, as well, and not just new objects.

This approach (keeping tabs on the new objects) has worked well for me, but it may not be the ideal solution.